<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è¿·å®«å°æ¸¸æˆï¼ˆæµç•…æ»‘è¡Œ + æ ¼å­å¯¹é½ï¼‰</title>
<style>
  body { background:#111; color:#eee; font-family:sans-serif; text-align:center; margin:0; padding:0; }
  canvas { background:#222; display:block; margin:10px auto; }
  .controls { margin:15px auto; width:200px; display:grid; grid-template-columns:60px 60px 60px; grid-template-rows:60px 60px 60px; justify-content:center; align-items:center; gap:5px; }
  .btn { background:#444; color:white; border:1px solid #666; font-size:24px; user-select:none; cursor:pointer; display:flex; justify-content:center; align-items:center; }
  #info { margin-top:10px; }
</style>
</head>
<body>
<h2>è¿·å®«å°æ¸¸æˆ ğŸ§©ï¼ˆæ»‘åŠ¨å¯¹é½æ ¼å­ï¼‰</h2>
<canvas id="game" width="600" height="600"></canvas>

<div id="info">
  â±ï¸ æ—¶é—´ï¼š<span id="timer">0.0</span> ç§’ ï½œ 
  ğŸ§© å…³å¡ï¼š<span id="level">1</span> ï½œ 
  ğŸ’¯ å½“å‰å¾—åˆ†ï¼š<span id="score">0</span> ï½œ 
  ğŸ† æ€»åˆ†ï¼š<span id="totalScore">0</span>
</div>

<div class="controls">
  <div></div>
  <div class="btn" id="up">â†‘</div>
  <div></div>
  <div class="btn" id="left">â†</div>
  <div></div>
  <div class="btn" id="right">â†’</div>
  <div></div>
  <div class="btn" id="down">â†“</div>
  <div></div>
</div>

<button class="btn" onclick="restart()">é‡æ–°å¼€å§‹</button>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let cols, rows, size;
let maze, player, exit;
let level = 1;
let timer = 0, timerId = null, gameOver = false;
let score = 0, totalScore = 0;
let pathTrail = []; 
let currentDir = null;
let slideSpeed = 0.2; // æ¯å¸§æ»‘åŠ¨æ ¼å­æ•°

// --- è¿·å®«ç”Ÿæˆ ---
function initMaze() {
  maze = Array.from({ length: rows }, () => Array(cols).fill(1));
}

function generateMaze(x, y) {
  const stack = [[x, y]];
  maze[y][x] = 0;
  const dirs = [[0,-1],[1,0],[0,1],[-1,0]];
  while(stack.length){
    const [cx, cy] = stack[stack.length-1];
    const shuffled = dirs.sort(() => Math.random()-0.5);
    let carved=false;
    for(const [dx,dy] of shuffled){
      const nx=cx+dx*2;
      const ny=cy+dy*2;
      if(ny>0 && ny<rows-1 && nx>0 && nx<cols-1 && maze[ny][nx]===1){
        maze[cy+dy][cx+dx]=0;
        maze[ny][nx]=0;
        stack.push([nx,ny]);
        carved=true; break;
      }
    }
    if(!carved) stack.pop();
  }
  // åˆ†å‰éšæœºæ‰“é€š
  for(let i=0;i<Math.floor(cols*rows*0.04);i++){
    const rx=Math.floor(Math.random()*(cols-2))+1;
    const ry=Math.floor(Math.random()*(rows-2))+1;
    if(maze[ry][rx]===1) maze[ry][rx]=0;
  }
  maze[1][1]=0;
}

function findExit(){
  for(let r=0;r<Math.max(cols,rows);r++){
    for(let dy=-r;dy<=r;dy++){
      for(let dx=-r;dx<=r;dx++){
        const x=cols-2-dx; const y=rows-2-dy;
        if(x>0 && y>0 && x<cols-1 && y<rows-1 && maze[y][x]===0) return {x,y};
      }
    }
  }
  return {x:cols-2,y:rows-2};
}

// --- ç»˜åˆ¶ ---
function drawMaze(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // å¢™
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      if(maze[y][x]===1){
        ctx.fillStyle='#555';
        ctx.fillRect(x*size,y*size,size,size);
      }
    }
  }
  // å·²èµ°è·¯å¾„
  ctx.fillStyle='rgba(255,0,0,0.3)';
  pathTrail.forEach(p=>{
    ctx.fillRect(p.x*size,p.y*size,size,size);
  });
  // å‡ºå£
  ctx.fillStyle='green';
  ctx.fillRect(exit.x*size,exit.y*size,size,size);
  // ç©å®¶
  ctx.fillStyle='red';
  ctx.fillRect(player.animX*size,player.animY*size,size,size);
}

// --- æ»‘åŠ¨ç§»åŠ¨ ---
function isWalkable(x,y){
  const cx=Math.floor(x);
  const cy=Math.floor(y);
  if(cx<0||cy<0||cx>=cols||cy>=rows) return false;
  return maze[cy][cx]===0;
}

function startSliding(dx,dy){
  if(gameOver) return;
  currentDir={dx,dy};
  requestAnimationFrame(slideStep);
}

function stopSliding() {
  if(!currentDir) return;
  currentDir=null;
  // åœæ­¢æ—¶å¯¹é½åˆ°æ ¼å­ä¸­å¿ƒ
  player.animX = player.x;
  player.animY = player.y;
  drawMaze();
}

function slideStep(){
  if(!currentDir || gameOver) return;
  let nx=player.animX+currentDir.dx*slideSpeed;
  let ny=player.animY+currentDir.dy*slideSpeed;

  // é™åˆ¶è¾¹ç•Œ
  nx = Math.max(0, Math.min(nx, cols-1));
  ny = Math.max(0, Math.min(ny, rows-1));

  if(isWalkable(nx,ny)){
    player.animX=nx;
    player.animY=ny;
    const newX=Math.floor(nx);
    const newY=Math.floor(ny);
    if(newX!==player.x || newY!==player.y){
      player.x=newX;
      player.y=newY;
      if(!pathTrail.some(p=>p.x===player.x && p.y===player.y)) pathTrail.push({x:player.x,y:player.y});
      score++; document.getElementById('score').textContent=score;
    }
  } else {
    stopSliding();
  }

  drawMaze();

  // åˆ°è¾¾å‡ºå£
  if(player.x===exit.x && player.y===exit.y){
    totalScore+=score;
    clearInterval(timerId);
    gameOver=true;
    setTimeout(()=>{
      alert(`ğŸ‰ é€šå…³ï¼ç¬¬ ${level} å…³å®Œæˆï¼\nç”¨æ—¶ ${timer.toFixed(1)} ç§’\nå¾—åˆ†ï¼š${score}\nç´¯è®¡æ€»åˆ†ï¼š${totalScore}`);
      level++; nextLevel();
    },200);
    return;
  }

  if(currentDir) requestAnimationFrame(slideStep);
}

// --- è®¡æ—¶ ---
function startTimer(){
  timer=0; document.getElementById('timer').textContent=timer.toFixed(1);
  clearInterval(timerId);
  timerId=setInterval(()=>{ timer+=0.1; document.getElementById('timer').textContent=timer.toFixed(1); },100);
}

// --- å…³å¡ ---
function startLevel(lv){
  cols=rows=lv*10;
  size=Math.floor(580/cols); 
  initMaze();
  generateMaze(1,1);
  exit=findExit();
  player={x:1,y:1,animX:1,animY:1};
  pathTrail=[{x:1,y:1}];
  score=0; gameOver=false;
  document.getElementById('level').textContent=lv;
  document.getElementById('score').textContent=score;
  document.getElementById('totalScore').textContent=totalScore;
  startTimer(); drawMaze();
}

function nextLevel(){ startLevel(level); }
function restart(){ level=1; totalScore=0; startLevel(level); }

// --- é”®ç›˜æ§åˆ¶ ---
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowUp') startSliding(0,-1);
  if(e.key==='ArrowDown') startSliding(0,1);
  if(e.key==='ArrowLeft') startSliding(-1,0);
  if(e.key==='ArrowRight') startSliding(1,0);
});
document.addEventListener('keyup',stopSliding);

// --- è§¦å±æ§åˆ¶ ---
['up','down','left','right'].forEach(id=>{
  const btn=document.getElementById(id);
  btn.addEventListener('mousedown',()=>{ 
    if(id==='up') startSliding(0,-1);
    if(id==='down') startSliding(0,1);
    if(id==='left') startSliding(-1,0);
    if(id==='right') startSliding(1,0);
  });
  btn.addEventListener('mouseup',stopSliding);
  btn.addEventListener('mouseleave',stopSliding);
  btn.addEventListener('touchstart',e=>{
    e.preventDefault();
    if(id==='up') startSliding(0,-1);
    if(id==='down') startSliding(0,1);
    if(id==='left') startSliding(-1,0);
    if(id==='right') startSliding(1,0);
  });
  btn.addEventListener('touchend',stopSliding);
});

restart();
</script>
</body>
</html><!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è¿·å®«å°æ¸¸æˆï¼ˆæµç•…æ»‘è¡Œ + æ ¼å­å¯¹é½ï¼‰</title>
<style>
  body { background:#111; color:#eee; font-family:sans-serif; text-align:center; margin:0; padding:0; }
  canvas { background:#222; display:block; margin:10px auto; }
  .controls { margin:15px auto; width:200px; display:grid; grid-template-columns:60px 60px 60px; grid-template-rows:60px 60px 60px; justify-content:center; align-items:center; gap:5px; }
  .btn { background:#444; color:white; border:1px solid #666; font-size:24px; user-select:none; cursor:pointer; display:flex; justify-content:center; align-items:center; }
  #info { margin-top:10px; }
</style>
</head>
<body>
<h2>è¿·å®«å°æ¸¸æˆ ğŸ§©ï¼ˆæ»‘åŠ¨å¯¹é½æ ¼å­ï¼‰</h2>
<canvas id="game" width="600" height="600"></canvas>

<div id="info">
  â±ï¸ æ—¶é—´ï¼š<span id="timer">0.0</span> ç§’ ï½œ 
  ğŸ§© å…³å¡ï¼š<span id="level">1</span> ï½œ 
  ğŸ’¯ å½“å‰å¾—åˆ†ï¼š<span id="score">0</span> ï½œ 
  ğŸ† æ€»åˆ†ï¼š<span id="totalScore">0</span>
</div>

<div class="controls">
  <div></div>
  <div class="btn" id="up">â†‘</div>
  <div></div>
  <div class="btn" id="left">â†</div>
  <div></div>
  <div class="btn" id="right">â†’</div>
  <div></div>
  <div class="btn" id="down">â†“</div>
  <div></div>
</div>

<button class="btn" onclick="restart()">é‡æ–°å¼€å§‹</button>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let cols, rows, size;
let maze, player, exit;
let level = 1;
let timer = 0, timerId = null, gameOver = false;
let score = 0, totalScore = 0;
let pathTrail = []; 
let currentDir = null;
let slideSpeed = 0.2; // æ¯å¸§æ»‘åŠ¨æ ¼å­æ•°

// --- è¿·å®«ç”Ÿæˆ ---
function initMaze() {
  maze = Array.from({ length: rows }, () => Array(cols).fill(1));
}

function generateMaze(x, y) {
  const stack = [[x, y]];
  maze[y][x] = 0;
  const dirs = [[0,-1],[1,0],[0,1],[-1,0]];
  while(stack.length){
    const [cx, cy] = stack[stack.length-1];
    const shuffled = dirs.sort(() => Math.random()-0.5);
    let carved=false;
    for(const [dx,dy] of shuffled){
      const nx=cx+dx*2;
      const ny=cy+dy*2;
      if(ny>0 && ny<rows-1 && nx>0 && nx<cols-1 && maze[ny][nx]===1){
        maze[cy+dy][cx+dx]=0;
        maze[ny][nx]=0;
        stack.push([nx,ny]);
        carved=true; break;
      }
    }
    if(!carved) stack.pop();
  }
  // åˆ†å‰éšæœºæ‰“é€š
  for(let i=0;i<Math.floor(cols*rows*0.04);i++){
    const rx=Math.floor(Math.random()*(cols-2))+1;
    const ry=Math.floor(Math.random()*(rows-2))+1;
    if(maze[ry][rx]===1) maze[ry][rx]=0;
  }
  maze[1][1]=0;
}

function findExit(){
  for(let r=0;r<Math.max(cols,rows);r++){
    for(let dy=-r;dy<=r;dy++){
      for(let dx=-r;dx<=r;dx++){
        const x=cols-2-dx; const y=rows-2-dy;
        if(x>0 && y>0 && x<cols-1 && y<rows-1 && maze[y][x]===0) return {x,y};
      }
    }
  }
  return {x:cols-2,y:rows-2};
}

// --- ç»˜åˆ¶ ---
function drawMaze(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // å¢™
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      if(maze[y][x]===1){
        ctx.fillStyle='#555';
        ctx.fillRect(x*size,y*size,size,size);
      }
    }
  }
  // å·²èµ°è·¯å¾„
  ctx.fillStyle='rgba(255,0,0,0.3)';
  pathTrail.forEach(p=>{
    ctx.fillRect(p.x*size,p.y*size,size,size);
  });
  // å‡ºå£
  ctx.fillStyle='green';
  ctx.fillRect(exit.x*size,exit.y*size,size,size);
  // ç©å®¶
  ctx.fillStyle='red';
  ctx.fillRect(player.animX*size,player.animY*size,size,size);
}

// --- æ»‘åŠ¨ç§»åŠ¨ ---
function isWalkable(x,y){
  const cx=Math.floor(x);
  const cy=Math.floor(y);
  if(cx<0||cy<0||cx>=cols||cy>=rows) return false;
  return maze[cy][cx]===0;
}

function startSliding(dx,dy){
  if(gameOver) return;
  currentDir={dx,dy};
  requestAnimationFrame(slideStep);
}

function stopSliding() {
  if(!currentDir) return;
  currentDir=null;
  // åœæ­¢æ—¶å¯¹é½åˆ°æ ¼å­ä¸­å¿ƒ
  player.animX = player.x;
  player.animY = player.y;
  drawMaze();
}

function slideStep(){
  if(!currentDir || gameOver) return;
  let nx=player.animX+currentDir.dx*slideSpeed;
  let ny=player.animY+currentDir.dy*slideSpeed;

  // é™åˆ¶è¾¹ç•Œ
  nx = Math.max(0, Math.min(nx, cols-1));
  ny = Math.max(0, Math.min(ny, rows-1));

  if(isWalkable(nx,ny)){
    player.animX=nx;
    player.animY=ny;
    const newX=Math.floor(nx);
    const newY=Math.floor(ny);
    if(newX!==player.x || newY!==player.y){
      player.x=newX;
      player.y=newY;
      if(!pathTrail.some(p=>p.x===player.x && p.y===player.y)) pathTrail.push({x:player.x,y:player.y});
      score++; document.getElementById('score').textContent=score;
    }
  } else {
    stopSliding();
  }

  drawMaze();

  // åˆ°è¾¾å‡ºå£
  if(player.x===exit.x && player.y===exit.y){
    totalScore+=score;
    clearInterval(timerId);
    gameOver=true;
    setTimeout(()=>{
      alert(`ğŸ‰ é€šå…³ï¼ç¬¬ ${level} å…³å®Œæˆï¼\nç”¨æ—¶ ${timer.toFixed(1)} ç§’\nå¾—åˆ†ï¼š${score}\nç´¯è®¡æ€»åˆ†ï¼š${totalScore}`);
      level++; nextLevel();
    },200);
    return;
  }

  if(currentDir) requestAnimationFrame(slideStep);
}

// --- è®¡æ—¶ ---
function startTimer(){
  timer=0; document.getElementById('timer').textContent=timer.toFixed(1);
  clearInterval(timerId);
  timerId=setInterval(()=>{ timer+=0.1; document.getElementById('timer').textContent=timer.toFixed(1); },100);
}

// --- å…³å¡ ---
function startLevel(lv){
  cols=rows=lv*10;
  size=Math.floor(580/cols); 
  initMaze();
  generateMaze(1,1);
  exit=findExit();
  player={x:1,y:1,animX:1,animY:1};
  pathTrail=[{x:1,y:1}];
  score=0; gameOver=false;
  document.getElementById('level').textContent=lv;
  document.getElementById('score').textContent=score;
  document.getElementById('totalScore').textContent=totalScore;
  startTimer(); drawMaze();
}

function nextLevel(){ startLevel(level); }
function restart(){ level=1; totalScore=0; startLevel(level); }

// --- é”®ç›˜æ§åˆ¶ ---
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowUp') startSliding(0,-1);
  if(e.key==='ArrowDown') startSliding(0,1);
  if(e.key==='ArrowLeft') startSliding(-1,0);
  if(e.key==='ArrowRight') startSliding(1,0);
});
document.addEventListener('keyup',stopSliding);

// --- è§¦å±æ§åˆ¶ ---
['up','down','left','right'].forEach(id=>{
  const btn=document.getElementById(id);
  btn.addEventListener('mousedown',()=>{ 
    if(id==='up') startSliding(0,-1);
    if(id==='down') startSliding(0,1);
    if(id==='left') startSliding(-1,0);
    if(id==='right') startSliding(1,0);
  });
  btn.addEventListener('mouseup',stopSliding);
  btn.addEventListener('mouseleave',stopSliding);
  btn.addEventListener('touchstart',e=>{
    e.preventDefault();
    if(id==='up') startSliding(0,-1);
    if(id==='down') startSliding(0,1);
    if(id==='left') startSliding(-1,0);
    if(id==='right') startSliding(1,0);
  });
  btn.addEventListener('touchend',stopSliding);
});

restart();
</script>
</body>
</html>